#!/usr/bin/env ruby
require "rubygems"
require "nokogiri"
require "uri"
require "open-uri"
require "date"
require "yaml"
require "fileutils"
require "tempfile"
require "erb"

class WeightEntry
    attr_reader :date, :weight

    def self.from_line line
        date, weight = line.split(" ", 2)
        date = Date.parse(date)
        weight = weight.to_f
        WeightEntry.new(date, weight)
    end

    def initialize date, weight
        @date = date
        @weight = weight
    end

    def to_s
        "#{@date} #{@weight}\n"
    end
end

class FoodEntry
    attr_reader :date, :kcal, :description

    def self.from_line line
        date, kcal, description = line.split(" ", 3)
        date = Date.parse(date)
        kcal = kcal.to_i
        description.chomp!
        FoodEntry.new(date, kcal, description)
    end

    def initialize date, kcal, description
        @date = date
        @kcal = kcal
        @description = description
    end

    def to_s
        "#{@date} #{@kcal} #{@description}\n"
    end
end

class Nom
    def initialize
        @nom_dir = File.join(Dir.home,".nom")
        if not Dir.exists? @nom_dir
            puts "Creating #{@nom_dir}"
            Dir.mkdir(@nom_dir)
        end

        @config = {}
        if File.exists? File.join(@nom_dir, "config")
            @config = YAML.load_file(File.join(@nom_dir, "config"))
        end

        @weights = read_file("weight", WeightEntry)
        @inputs = read_file("input", FoodEntry)

        d = start_date
        @inputs.delete_if{|i| i.date < d}
        @weights.delete_if{|w| w.date < d}

        @inputs_at = {}
        @inputs.each do |i|
            @inputs_at[i.date] = [] if @inputs_at[i.date].nil?
            @inputs_at[i.date] << i
        end

        if @weights.empty?
            print "Please enter your current weight: "
            weight [STDIN.gets.chomp]
        end

        alpha = 0.1
        beta = 0.1
        trend = -rate/7.0
        @moving_average_at = {start_date => weight_at(start_date)}
        (start_date+1).upto(end_date) do |d|
            @moving_average_at[d] = alpha*weight_at(d) + (1-alpha)*(@moving_average_at[d-1]+trend)
            trend = beta*(@moving_average_at[d]-@moving_average_at[d-1]) + (1-beta)*trend
        end

        alpha = 0.05
        @allowed_at = {}

        rates.each do |r|
            @allowed_at[r] = {start_date => weight_at(start_date)*25*1.2 - r*1000}
            (start_date+1).upto(end_date) do |d|
                intake = consumed_at(d-1)
                if intake == 0
                    @allowed_at[r][d] = @allowed_at[r][d-1]
                    next
                end
                loss = moving_average_at(d-1) - moving_average_at(d)
                kcal_per_kg_body_fat = 7000
                burned_kcal = loss*kcal_per_kg_body_fat
                wanted_to_burn = r*1000
                burned_too_little = wanted_to_burn - burned_kcal
                new_estimation = intake - burned_too_little
                @allowed_at[r][d] = alpha*new_estimation + (1-alpha)*@allowed_at[r][d-1]
            end
            (end_date+1).upto(Date.today) do |d|
                @allowed_at[r][d] = @allowed_at[r][d-1]
            end
        end
    end

    def status
        kg_lost = moving_average_at(start_date) - moving_average_at(end_date)
        puts "#{kg_lost.round(1)} kg down (#{(100*kg_lost/(kg_lost+kg_to_go)).round}%), #{kg_to_go.round(1)} kg to go! You'll reach your goal in approximately #{format_duration(days_to_go)}."

        log_since([start_date,Date.today-1].max)
    end

    def log
        log_since(start_date)
    end

    def grep args
        term = args.join(" ")

        inputs = @inputs.select{|i| i.description =~ Regexp.new(term, Regexp::IGNORECASE)}

        if inputs.empty?
            puts "(no matching entries found)"
        end

        inputs.each do |i|
            entry(quantize(i.kcal), i.date.to_s+" "+i.description)
        end

        separator
        entry(quantize(inputs.inject(0){|sum, i| sum+i.kcal}), "total")
    end

    def weight args
        unless @weights.select{|w| w.date == Date.today }.empty?
            raise "You already entered a weight for today. Use `nom editw` to modify it."
        end

        weight = args.pop.to_f
        entry = WeightEntry.new(Date.today, weight)
        @weights << entry
        open(File.join(@nom_dir,"weight"), "a") do |f|
            f << entry.to_s
        end

        initialize
        plot
    end

    def nom args
        nom_entry args, (Time.now-5*60*60).to_date
    end

    def yesterday args
        nom_entry args, Date.today-1
    end

    def search args
        puts "Previous log entries:"
        grep(args)
        term = args.join(" ")
        puts
        term = term.encode("ISO-8859-1")
        url = "http://fddb.info/db/de/suche/?udd=0&cat=site-de&search=#{URI.escape(term)}"

        page = Nokogiri::HTML(open(url))
        results = page.css(".standardcontent a").map{|a| a["href"]}.select{|href| href.include? "lebensmittel"}

        results[0..4].each do |result|
            page = Nokogiri::HTML(open(result))
            title = page.css(".breadcrumb a").last.text
            brand = page.css(".standardcontent p a").select{|a| a["href"].include? "hersteller"}.first.text
            puts "#{title} (#{brand})"

            page.css(".serva").each do |serving|
                size = serving.css("a.servb").text
                kcal = serving.css("div")[5].css("div")[1].text.to_i
                #kj = serving.css("div")[2].css("div")[1].text.to_i
                puts "    (#{quantize(kcal)}) #{size}"
            end
        end
    end

    def plot
        weight_dat = Tempfile.new("weight")
        (start_date).upto(end_date) do |date|
            weight_dat << "#{date}\t"
            if @weights.select{|w| w.date == date }.empty?
                weight_dat << "-"
            else
                weight_dat << "#{weight_at(date)}"
            end
            weight_dat << "\t#{moving_average_at(date)}\t\n"
        end
        weight_dat.close

        input_dat = Tempfile.new("input")
        input_dat << "#{start_date-1}\t0\t0\n"
        (start_date).upto(Date.today) do |date|
            input_dat << "#{date}\t"
            if consumed_at(date) == 0
                input_dat << "-"
            else
                input_dat << quantize(consumed_at(date))
            end
            rates.each do |r|
                input_dat << "\t#{quantize(allowed_kcal(date, r))}"
            end
            input_dat << "\n"
        end
        input_dat.close

        svg = Tempfile.new(["plot", ".svg"])
        svg.close

        plt_erb = IO.read(File.join(File.dirname(__FILE__), "nom.plt.erb"))

        plt = Tempfile.new("plt")
        plt << ERB.new(plt_erb).result(binding)
        plt.close

        system("gnuplot "+plt.path)

        image_viewer = get_config("image_viewer", "Image viewer/browser")
        system(image_viewer+" "+svg.path)
    end

    def edit
        edit_file "input"
    end

    def editw
        edit_file "weight"
    end

    private

    def nom_entry args, date
        factors = args.pop.split("x")
        kcal = factors.map{ |f| f.to_f }.inject(1){ |p,f| p*f }
        if kcal == 0
            raise "energy term cannot be zero"
        end

        description = args.join(" ")
        entry = FoodEntry.new(date, kcal, description)

        open(File.join(@nom_dir,"input"), "a") do |f|
            p entry.date
            p @inputs.last.date
            if entry.date != @inputs.last.date
                f << "\n"
            end
            f << entry.to_s
        end

        @inputs << entry
        if @inputs_at[date].nil?
            @inputs_at[date] = []
        end
        @inputs_at[date] << entry

        status
    end

    def edit_file filename
        editor = ENV["EDITOR"]
        editor = "vim" if editor.nil?
        system("#{editor} #{ENV["HOME"]}/.nom/#{filename}")
    end

    def allowed_kcal date, r=rate
        return @allowed_at[r][date]
    end

    def weight_at date
        w = @weights.select{|w| w.date == date }
        if w.empty?
            prev_weight = @weights.select{|w| w.date < date }.max_by{|w| w.date}
            next_weight = @weights.select{|w| w.date > date }.min_by{|w| w.date}
            raise "Need a weight for #{date}" if next_weight.nil?
            raise "Need a weight for #{date}" if prev_weight.nil?
            prev_weight.weight + (prev_weight.weight-next_weight.weight)/(prev_weight.date-next_weight.date)*(date-prev_weight.date)
        else
            w.first.weight
        end
    end

    def consumed_at date
        inputs_at(date).inject(0){ |sum, i| sum+i.kcal }
    end

    def moving_average_at date
        @moving_average_at[date]
    end

    def kg_to_go
        moving_average_at(end_date) - goal
    end

    def kcal_to_burn
        kcal_per_kg_body_fat = 7000
        kg_to_go * kcal_per_kg_body_fat
    end

    def days_to_go
        [0, kcal_to_burn/(rate*1000)].max
    end

    def balance_start
        get_config("balance_start", "Start date of balance calculation", start_date)
    end

    def balance_end
        Date.today-1
    end

    def kcal_balance
        sum = 0
        balance_start.upto(balance_end) do |d|
            if consumed_at(d) != 0
                sum += consumed_at(d) - allowed_kcal(d)
            end
        end
        sum
    end

    def start_date
        first_start = @weights.first.date

        if has_config("start_date")
            user_start = get_config("start_date", "start date")
            [user_start, first_start].max
        else
            clever_start = @weights.first.date
            @weights.reverse.each_cons(2) do |cur, prev|
                if cur.date - prev.date > 30
                    clever_start = cur.date
                    break
                end
            end
            clever_start
        end
    end

    def end_date
        @weights.last.date
    end

    def quantize kcal
        return (kcal/get_config("unit", "kcal per energy unit", 1).to_f).round
    end

    def format_date date
        if date == Date.today
            return "Today"
        elsif date == Date.today-1
            return "Yesterday"
        else
            return date.to_s
        end
    end

    def format_duration days
        if days <= 7
            n = days
            unit = "day"
        elsif days <= 7*4
            n = (days/7.0).round(1)
            unit = "week"
        else
            n = (days/7.0/4.0).round(1)
            unit = "month"
        end
        "#{n} #{unit}#{n == 1 ? "" : "s"}"
    end

    def entry value, text=""
        puts "#{" "*(6-value.to_s.length)}(#{value}) #{text}"
    end

    def separator
        puts "---------------------"
    end

    def log_since start
        remaining = 0
        start.upto(Date.today) do |date|
            remaining += allowed_kcal(date)
            puts
            puts "#{format_date(date)}: (#{quantize(allowed_kcal(date))})"
            puts
            remaining = allowed_kcal(date)
            inputs_at(date).each do |i|
                entry(quantize(i.kcal), i.description)
                remaining -= i.kcal
            end
            separator
            entry(quantize(remaining), "remaining (#{(100-100.0*remaining/allowed_kcal(date)).round}% used)")
        end
        if kcal_balance > 0
            entry(quantize(kcal_balance.abs), "too much since #{balance_start}")
        end
    end

    def read_file name, klass
        result = []
        file = File.join(@nom_dir,name)
        FileUtils.touch(file)
        IO.readlines(file).each do |line|
            next if line == "\n"
            result << klass::from_line(line)
        end
        result
    end

    def goal
        get_config("goal", "Goal weight").to_f
    end

    def rate
        get_config("rate", "Weight loss per week").to_f
    end

    def rates
        [0, rate]
    end

    def has_config name
        @config.has_key?(name)
    end

    def get_config name, description, default=nil
        if not has_config(name)
            if default
                return default
            else
                print "Please enter a value for '#{description}': "
                @config[name] = STDIN.gets.chomp
                open(File.join(@nom_dir,"config"), "w") do |f|
                    f << @config.to_yaml
                end
            end
        end

        return @config[name]
    end

    def inputs_at date
        @inputs_at[date] || []
    end
end

commands = [
    [ "status", nil, nil, "Display a short food log" ],
    [ "weight", "w", "<weight>", "Report a weight measurement" ],
    [ "search", "s", "<term>", "Search for a food item in the web" ],
    [ "nom", "n", "<description> <energy>", "Report that you ate something" ],
    [ "yesterday", "y", "<description> <energy>", "Like nom, but for yesterday" ],
    [ "plot", "p", nil, "Plot a weight/intake graph" ],
    [ "log", "l", nil, "Display the full food log" ],
    [ "grep", "g", "<term>", "Search in the food log" ],
    [ "edit", "e", nil, "Edit the input file" ],
    [ "editw", "ew", nil, "Edit the weight file" ],
    [ "help", nil, nil, "Print this help" ],
]

nom = Nom.new

cmd_name = ARGV.shift or "status"
command = commands.find{|c| c[0] == cmd_name or c[1] == cmd_name}

if command.nil?
    ARGV.unshift(cmd_name)
    if ARGV.last.to_f != 0
        if ARGV.size > 1
            command = commands.find{|c| c[0] == "nom"}
        else
            command = commands.find{|c| c[0] == "weight"}
        end
    else
        command = commands.find{|c| c[0] == "search"}
    end
end

if command[0] == "help"
    puts "Available subcommands:"
    commands.each do |c|
        puts "  "+"#{c[1].to_s.rjust(2)}#{c[1] ? "," : " "} #{c[0]} #{c[2]}".ljust(32)+c[3]
    end
    puts "There are some useful defaults:"
    puts "      "+"(no arguments)".ljust(28)+"status"
    puts "      "+"<number>".ljust(28)+"weight <number>"
    puts "      "+"<term>".ljust(28)+"search <term>"
    puts "      "+"<term> <number>".ljust(28)+"nom <term> <number>"
else
    begin
        if ARGV.empty?
            nom.send(command[0])
        else
            nom.send(command[0], ARGV)
        end
    rescue Exception => e
        puts e.backtrace
        puts e.message
        puts "Usage: nom #{command[0]} #{command[2]}"
    end
end
