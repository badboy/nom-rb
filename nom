#!/usr/bin/env ruby
require "rubygems"
require "nokogiri"
require "os"
require "uri"
require "open-uri"
require "date"
require "yaml"
require "fileutils"
require "tempfile"
require "erb"
require "mkmf"

class WeightEntry
    attr_reader :date, :weight

    def self.from_line line
        date, weight = line.split(" ", 2)
        date = Date.parse(date)
        weight = weight.to_f
        WeightEntry.new(date, weight)
    end

    def initialize date, weight
        @date = date
        @weight = weight
    end

    def to_s
        "#{@date} #{@weight}\n"
    end
end

class FoodEntry
    attr_reader :date, :kcal, :description

    def self.from_line line
        date, kcal, description = line.split(" ", 3)
        date = Date.parse(date)
        kcal = kcal.to_i
        description.chomp!
        FoodEntry.new(date, kcal, description)
    end

    def initialize date, kcal, description
        @date = date
        @kcal = kcal
        @description = description
    end

    def to_s
        "#{@date} #{@kcal} #{@description}\n"
    end
end

class Nom
    def initialize
        @nom_dir = File.join(Dir.home,".nom")

        if not Dir.exists? @nom_dir
            puts "Creating #{@nom_dir}"
            Dir.mkdir(@nom_dir)
        end

        @weights = read_file("weight", WeightEntry)
        @inputs = read_file("input", FoodEntry)

        @inputs_at = {}
        @inputs.each do |i|
            @inputs_at[i.date] = [] if @inputs_at[i.date].nil?
            @inputs_at[i.date] << i
        end

        if @weights.empty?
            print "Please enter your current weight: "
            weight [gets.chomp]
        end

        alpha = 0.1
        beta = 0.1
        trend = -rate/7.0
        @moving_average_at = {start_date => weight_at(start_date)}
        (start_date+1).upto(end_date) do |d|
            @moving_average_at[d] = alpha*weight_at(d) + (1-alpha)*(@moving_average_at[d-1]+trend)
            trend = beta*(@moving_average_at[d]-@moving_average_at[d-1]) + (1-beta)*trend
        end

        @allowed_at = {start_date => @weights.first.weight*25*1.2 - rate*1000}
        alpha = 0.1
        (start_date+1).upto(end_date) do |d|
            intake = consumed_at(d-1)
            loss = moving_average_at(d-1) - moving_average_at(d)
            kcal_per_kg_body_fat = 7000
            burned_kcal = loss*kcal_per_kg_body_fat
            wanted_to_burn = rate*1000
            burned_too_little = wanted_to_burn - burned_kcal
            new_estimation = intake - burned_too_little
            @allowed_at[d] = alpha*new_estimation + (1-alpha)*@allowed_at[d-1]
        end
        (end_date+1).upto(Date.today) do |d|
            @allowed_at[d] = @allowed_at[d-1]
        end
    end

    def status
        if Date.today >= start_date+skip_first
            kg_lost = moving_average_at(start_date+skip_first) - moving_average_at(end_date)
            puts "#{kg_lost.round(1)} kg down (#{(100*kg_lost/(kg_lost+kg_to_go)).round}%), #{kg_to_go.round(1)} kg to go!"
        end
        log_since(Date.today - 1)
    end

    def log
        log_since(start_date)
    end

    def grep args
        term = args.join(" ")

        inputs = @inputs.select{|i| i.description =~ Regexp.new(term, Regexp::IGNORECASE)}

        if inputs.empty?
            puts "(no matching entries found)"
        end

        inputs.each do |i|
            entry(quantize(i.kcal), i.date.to_s+" "+i.description)
        end

        separator
        entry(quantize(inputs.inject(0){|sum, i| sum+i.kcal}), "total")
    end

    def weight args
        weight = args.pop.to_f
        @weights << WeightEntry.new(Date.today, weight)

        open(File.join(@nom_dir,"weight"), "w") do |f|
            @weights.each do |e|
                f << e.to_s
            end
        end

        initialize
        plot
    end

    def nom args
        factors = args.pop.split("x")
        kcal = factors.map{ |f| f.to_f }.inject(1){ |p,f| p*f }
        if kcal == 0
            raise "energy term cannot be zero"
        end

        description = args.join(" ")
        entry = FoodEntry.new(Date.today, kcal, description)
        @inputs << entry
        if @inputs_at[Date.today].nil?
            @inputs_at[Date.today] = []
        end
        @inputs_at[Date.today] << entry

        open(File.join(@nom_dir,"input"), "w") do |f|
            last_date = @inputs.first.date
            @inputs.each do |e|
                if last_date < e.date
                    f << "\n"
                end
                f << e.to_s
                last_date = e.date
            end
        end

        status
    end

    def search args
        puts "Previous log entries:"
        grep(args)
        term = args.join(" ")
        puts
        term = term.encode("ISO-8859-1")
        url = "http://fddb.info/db/de/suche/?udd=0&cat=site-de&search=#{URI.escape(term)}"

        page = Nokogiri::HTML(open(url))
        results = page.css(".standardcontent a").map{|a| a["href"]}.select{|href| href.include? "lebensmittel"}

        results[0..4].each do |result|
            page = Nokogiri::HTML(open(result))
            title = page.css(".breadcrumb a").last.text
            brand = page.css(".standardcontent p a").select{|a| a["href"].include? "hersteller"}.first.text
            puts "#{title} (#{brand})"

            page.css(".serva").each do |serving|
                size = serving.css("a.servb").text
                kcal = serving.css("div")[5].css("div")[1].text.to_i
                #kj = serving.css("div")[2].css("div")[1].text.to_i
                puts "    (#{quantize(kcal)}) #{size}"
            end
        end
    end

    def plot
        weight_dat = Tempfile.new("weight")
        (start_date).upto(end_date) do |date|
            weight_dat << "#{date}\t#{@weights.select{|w| w.date == date }.empty? ? "-1000" : weight_at(date)}\t#{moving_average_at(date)}\t\n"
        end
        weight_dat.close

        input_dat = Tempfile.new("input")
        (start_date).upto(Date.today) do |date|
            input_dat << "#{date}\t#{quantize(allowed_kcal(date))}\t#{quantize(consumed_at(date))}\n"
        end
        input_dat.close

        svg = Tempfile.new(["plot", ".svg"])
        svg.close

        plt_erb = IO.read(File.join(File.dirname(__FILE__), "nom.plt.erb"))

        plt = Tempfile.new("plt")
        plt << ERB.new(plt_erb).result(binding)
        plt.close

        system("gnuplot "+plt.path)

        image_viewer = get_config("image_viewer", "Image viewer/browser")
        system(image_viewer+" "+svg.path)
    end

    def edit
        edit_file "input"
    end

    def editw
        edit_file "weight"
    end

    private

    def edit_file filename
        editor = ENV["EDITOR"]
        editor = "vim" if editor.nil?
        system("#{editor} #{ENV["HOME"]}/.nom/#{filename}")
    end

    def allowed_kcal date
        return @allowed_at[date]
    end

    def weight_at date
        w = @weights.select{|w| w.date == date }
        if w.empty?
            prev_weight = @weights.select{|w| w.date < date }.max_by{|w| w.date}
            next_weight = @weights.select{|w| w.date > date }.min_by{|w| w.date}
            raise "Need a weight for #{date}" if next_weight.nil?
            prev_weight.weight + (prev_weight.weight-next_weight.weight)/(prev_weight.date-next_weight.date)*(date-prev_weight.date)
        else
            w.first.weight
        end
    end

    def consumed_at date
        inputs_at(date).inject(0){ |sum, i| sum+i.kcal }
    end

    def moving_average_at date
        @moving_average_at[date]
    end

    def kg_to_go
        moving_average_at(end_date) - goal
    end

    def kcal_to_burn
        kcal_per_kg_body_fat = 7000
        kg_to_go * kcal_per_kg_body_fat
    end

    def days_to_go
        kcal_to_burn/(rate*1000)
    end

    def start_date
        if @inputs.empty?
            @weights.first.date
        else
            [@inputs.first.date, @weights.first.date].min
        end
    end

    def end_date
        @weights.last.date
    end

    def quantize kcal
        return (kcal/get_config("unit", "kcal per energy unit", 1).to_f).round
    end

    def format_date date
        if date == Date.today
            return "Today"
        elsif date == Date.today-1
            return "Yesterday"
        else
            return date.to_s
        end
    end

    def entry value, text=""
        puts "#{" "*(6-value.to_s.length)}(#{value}) #{text}"
    end

    def separator
        puts "---------------------"
    end

    def log_since start
        remaining = 0
        start.upto(Date.today) do |date|
            remaining += allowed_kcal(date)
            puts
            puts "#{format_date(date)}: (#{quantize(allowed_kcal(date))})"
            puts
            remaining = allowed_kcal(date)
            inputs_at(date).each do |i|
                entry(quantize(i.kcal), i.description)
                remaining -= i.kcal
            end
            separator
            entry(quantize(remaining), "remaining")
        end
    end

    def read_file name, klass
        result = []
        file = File.join(@nom_dir,name)
        FileUtils.touch(file)
        IO.readlines(file).each do |line|
            next if line == "\n"
            result << klass::from_line(line)
        end
        result
    end

    def goal
        get_config("goal", "Goal weight").to_f
    end

    def rate
        get_config("rate", "Weight loss per week").to_f
    end

    def skip_first
        7
    end

    def get_config name, description, default=nil
        config = {}

        if File.exists? File.join(@nom_dir,"config")
            config = YAML.load_file(File.join(@nom_dir,"config"))
        end

        if not config[name]
            if default
                return default
            else
                print "Please enter a value for '#{description}': "
                config[name] = gets
                open(File.join(@nom_dir,"config"), "w") do |f|
                    f << config.to_yaml
                end
            end
        end

        return config[name]
    end

    def inputs_at date
        @inputs_at[date] || []
    end
end

commands = [
    [ "status", nil, nil, "Display a short food log" ],
    [ "weight", "w", "<weight>", "Report a weight measurement" ],
    [ "search", "s", "<term>", "Search for a food item in the web" ],
    [ "nom", "n", "<description> <energy>", "Report that you ate something" ],
    [ "plot", "p", nil, "Plot a weight/intake graph" ],
    [ "log", "l", nil, "Display the full food log" ],
    [ "grep", "g", "<term>", "Search in the food log" ],
    [ "edit", "e", nil, "Edit the input file" ],
    [ "editw", "ew", nil, "Edit the weight file" ],
    [ "help", nil, nil, "Print this help" ],
]

nom = Nom.new

cmd_name = ARGV.shift or "status"
command = commands.find{|c| c[0] == cmd_name or c[1] == cmd_name}

if command.nil?
    ARGV.unshift(cmd_name)
    if ARGV.last.to_f != 0
        if ARGV.size > 1
            command = commands.find{|c| c[0] == "nom"}
        else
            command = commands.find{|c| c[0] == "weight"}
        end
    else
        command = commands.find{|c| c[0] == "search"}
    end
end

if command[0] == "help"
    puts "Available subcommands:"
    commands.each do |c|
        puts "  "+"#{c[1].to_s.rjust(2)}#{c[1] ? "," : " "} #{c[0]} #{c[2]}".ljust(32)+c[3]
    end
    puts "There are some useful defaults:"
    puts "      "+"(no arguments)".ljust(28)+"status"
    puts "      "+"<number>".ljust(28)+"weight <number>"
    puts "      "+"<term>".ljust(28)+"search <term>"
    puts "      "+"<term> <number>".ljust(28)+"nom <term> <number>"
else
    begin
        if ARGV.empty?
            nom.send(command[0])
        else
            nom.send(command[0], ARGV)
        end
    rescue Exception => e
        puts e.backtrace
        puts e.message
        puts "Usage: nom #{command[0]} #{command[2]}"
    end
end
